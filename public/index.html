<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Maze Router - TON Transaction Router"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Maze Router</title>
    <!-- Скрипт для работы с API напрямую через XMLHttpRequest -->
    <script>
      // Адрес API
      const API_URL = 'https://maze-router-api.vercel.app/api';
      // Адреса CORS прокси-серверов
      const PROXY_URLS = [
        'https://corsproxy.io/?',
        'https://cors-anywhere.herokuapp.com/',
        'https://api.allorigins.win/raw?url=',
        'https://proxy.cors.sh/'
      ];
      
      // Функция для прямого выполнения запроса через XMLHttpRequest
      function directApiRequest(method, url, data = null) {
        return new Promise((resolve, reject) => {
          console.log(`Выполнение прямого ${method} запроса к ${url}`);
          
          const xhr = new XMLHttpRequest();
          xhr.open(method, url, true);
          xhr.setRequestHeader('Content-Type', 'application/json');
          
          xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                const response = JSON.parse(xhr.responseText);
                console.log('Успешный ответ API:', response);
                resolve(response);
              } catch (e) {
                console.error('Ошибка при разборе JSON ответа:', e);
                reject(new Error('Некорректный формат ответа'));
              }
            } else {
              console.error('HTTP ошибка:', xhr.status, xhr.statusText);
              reject(new Error(`HTTP ошибка! Статус: ${xhr.status}`));
            }
          };
          
          xhr.onerror = function() {
            console.error('Ошибка сети при выполнении запроса');
            reject(new Error('Ошибка сети'));
          };
          
          xhr.timeout = 10000; // 10 секунд таймаут
          xhr.ontimeout = function() {
            console.error('Превышено время ожидания запроса');
            reject(new Error('Таймаут запроса'));
          };
          
          if (data) {
            xhr.send(JSON.stringify(data));
          } else {
            xhr.send();
          }
        });
      }
      
      // Функция для выполнения запроса через прокси
      async function proxyRequest(method, endpoint, data = null) {
        // Перебираем все прокси-серверы последовательно
        for (let i = 0; i < PROXY_URLS.length; i++) {
          const proxyUrl = PROXY_URLS[i];
          const targetUrl = `${API_URL}/${endpoint}`;
          const encodedUrl = encodeURIComponent(targetUrl);
          const fullUrl = proxyUrl.includes('?') ? `${proxyUrl}${encodedUrl}` : `${proxyUrl}${targetUrl}`;
          
          try {
            console.log(`Попытка ${i+1}/${PROXY_URLS.length} через прокси ${proxyUrl}`);
            
            // Для прокси-серверов, которые требуют URL-параметры
            if (proxyUrl.includes('allorigins')) {
              const response = await fetch(fullUrl);
              if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status}`);
              return await response.json();
            }
            
            // Для других прокси используем стандартный fetch с методом и данными
            const response = await fetch(fullUrl, {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: data ? JSON.stringify(data) : undefined
            });
            
            if (!response.ok) throw new Error(`HTTP ошибка! Статус: ${response.status}`);
            return await response.json();
          } catch (error) {
            console.warn(`Ошибка через прокси ${proxyUrl}:`, error.message);
            // Если это последний прокси в списке, пробрасываем ошибку
            if (i === PROXY_URLS.length - 1) throw error;
            // Иначе продолжаем с следующим прокси
          }
        }
      }

      // Глобальный объект для работы с API
      window.DirectMazeAPI = {
        // Функция для расчета комиссии
        calculateCommission: async function(amount) {
          console.log('DirectMazeAPI.calculateCommission вызван с суммой:', amount);
          
          try {
            // Сначала пробуем прямой запрос через XMLHttpRequest
            return await directApiRequest('POST', `${API_URL}/calculate`, { amount });
          } catch (directError) {
            console.warn('Прямой запрос не удался, пробуем через прокси:', directError);
            try {
              // Если прямой запрос не удался, пробуем через прокси
              return await proxyRequest('POST', 'calculate', { amount });
            } catch (proxyError) {
              console.error('Все методы запроса не удались:', proxyError);
              throw proxyError;
            }
          }
        },
        
        // Функция для подготовки транзакции
        prepareTransfer: async function(to, amount) {
          console.log('DirectMazeAPI.prepareTransfer вызван:', { to, amount });
          
          try {
            // Сначала пробуем прямой запрос через XMLHttpRequest
            return await directApiRequest('POST', `${API_URL}/transfer`, { to, amount });
          } catch (directError) {
            console.warn('Прямой запрос не удался, пробуем через прокси:', directError);
            try {
              // Если прямой запрос не удался, пробуем через прокси
              return await proxyRequest('POST', 'transfer', { to, amount });
            } catch (proxyError) {
              console.error('Все методы запроса не удались:', proxyError);
              throw proxyError;
            }
          }
        }
      };
      
      // Инициализируем MazeRouterProxy для совместимости
      window.MazeRouterProxy = window.DirectMazeAPI;
      
      console.log('DirectMazeAPI и MazeRouterProxy успешно инициализированы с использованием XMLHttpRequest');
    </script>
  </head>
  <body>
    <noscript>Вам необходимо включить JavaScript для запуска приложения.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html> 